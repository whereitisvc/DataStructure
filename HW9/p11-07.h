/*	================== graphBrdthFrst ===================	 Process the data of the graph in breadth-first order. 	    Pre  graph is pointer to graph head structure	    Post graph has been processed	    Processed Flag: 0 = not processed	                    1 = enqueued	                    2 = processed*/void graphBrdthFrst (GRAPH* graph,                      void (*process) (void* dataPtr)){//	Local Definitions 	bool    success;	VERTEX* walkPtr;	VERTEX* vertexPtr;	VERTEX* vertToPtr;	QUEUE*  queue;		ARC*    arcWalkPtr;	//	Statements 	if (!graph->first)	    return; 	// Set processed flags to not processed 	walkPtr = graph->first;	while (walkPtr)	   {	    walkPtr->processed = 0;	    walkPtr            = walkPtr->pNextVertex;	   } // while 		// Process each vertex in list 	queue = createQueue ();	walkPtr = graph->first;	while (walkPtr)	   {	    if (walkPtr->processed < 2)	       {	        if (walkPtr->processed < 1)	           {	            // Enqueue & set flag to queue 	            success = enqueue(queue, walkPtr);	            if (!success)	               printf("\aQueue overflow 100\a\n"),	               exit (100);	            walkPtr->processed = 1;	           } // if processed < 1 	       } // if processed < 2 	    // Process descendents of vertex at que frnt 	    while (!emptyQueue (queue))	       {	        dequeue(queue, (void**)&vertexPtr);	        process (vertexPtr->dataPtr);	        vertexPtr->processed = 2;	        	        // Enqueue vertices from adjacency list 	        arcWalkPtr = vertexPtr->pArc;	        while (arcWalkPtr)	          {	           vertToPtr = arcWalkPtr->destination;	           if (vertToPtr->processed == 0)	             {	              success = enqueue(queue, vertToPtr);	              if (!success)	                printf("\aQueue overflow 101\a\n"),	                   exit (101);	              vertToPtr->processed = 1;	             } // if vertToPtr 	           arcWalkPtr = arcWalkPtr->pNextArc;	          } // while pWalkArc 	       } // while !emptyQueue 	    walkPtr = walkPtr->pNextVertex;	   } // while walkPtr 	destroyQueue(queue); 	return; } // graphBrdthFrst 